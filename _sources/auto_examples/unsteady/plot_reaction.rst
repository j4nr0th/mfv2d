
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/unsteady/plot_reaction.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_unsteady_plot_reaction.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_unsteady_plot_reaction.py:


Reaction Equation
=================

The reaction equation is probably the simples non-trivial unsteady differenital
equation. It is given by equation :eq:`unsteady-reaction-direct-equation`. If
the forcing :math:`f` is only space dependent, then it has a very simple
analytical solution given by :eq:`unsteady-reaction-direct-solution`, where
:math:`u_\mathrm{initial} = u(x, y, 0)` and
:math:`u_\mathrm{final} = f(x, y) / \alpha`.

.. math::
    :label: unsteady-reaction-direct-equation

    \frac{\partial u}{\partial t} + \alpha u = + f

.. math::
    :label: unsteady-reaction-direct-solution

    u(x, y, t) = u_\mathrm{initial} (1 - e^{-\alpha t}) + u_\mathrm{final}
    e^{-\alpha t}


In the 2D case with differential geometry, this problem can be solved either
by taking :math:`u` to be a 0-form or a 2-form. For this example, the 0-form
is taken.

For the error measurements used to check for convergence, both :math:`L^2` and
:math:`H^1` norms will be used to compute error for each time step. These values
will then be integrated using trapezoidal integration to find total error over
the entire time march. This error will then be compared for different number of
time steps over the same time period.

.. GENERATED FROM PYTHON SOURCE LINES 35-52

.. code-block:: Python


    import numpy as np
    import numpy.typing as npt
    import pyvista as pv
    import rmsh
    from matplotlib import pyplot as plt
    from mfv2d import (
        KFormSystem,
        KFormUnknown,
        Mesh2D,
        SolverSettings,
        SystemSettings,
        TimeSettings,
        solve_system_2d,
    )
    from scipy.integrate import trapezoid








.. GENERATED FROM PYTHON SOURCE LINES 53-64

Setup
-----

The initial and final solutions were taken as
:math:`u_\mathrm{initial} = 2 \cos(\frac{\pi x}{2}) \cos(\frac{\pi y}{2})`
and :math:`u_\mathrm{final} = \sin(\pi x) \cos(\pi y)`. As for the value
of the rate coefficient, the value of :math:`\alpha = 0.25` was chosen.

The problem would be simulated on the time interval :math:`t \in [0, 10]`.



.. GENERATED FROM PYTHON SOURCE LINES 65-102

.. code-block:: Python


    T_END = 10
    ALPHA = 0.25


    def initial_u(x: npt.NDArray[np.floating], y: npt.NDArray[np.floating]):
        """Screw initial solution."""
        return 2 * np.cos(np.pi * x / 2) * np.cos(np.pi * y / 2)


    def initial_q(x: npt.NDArray[np.floating], y: npt.NDArray[np.floating]):
        """Screw initial curl."""
        return np.stack(
            (
                -np.pi * np.cos(np.pi * x / 2) * np.sin(np.pi * y / 2),
                np.pi * np.sin(np.pi * x / 2) * np.cos(np.pi * y / 2),
            ),
            axis=-1,
        )


    def final_u(x: npt.NDArray[np.floating], y: npt.NDArray[np.floating]):
        """Steady state forcing."""
        return np.sin(np.pi * x) * np.cos(np.pi * y)


    def final_q(x: npt.NDArray[np.floating], y: npt.NDArray[np.floating]):
        """Steady state curl."""
        return np.stack(
            (
                -np.pi * np.sin(np.pi * x) * np.sin(np.pi * y),
                -np.pi * np.cos(np.pi * x) * np.cos(np.pi * y),
            ),
            axis=-1,
        )









.. GENERATED FROM PYTHON SOURCE LINES 103-109

System Setup
------------

The system being solved is formulated bellow. An additional equation was introducted
to obtain the curl of the solution, so that the :math:`H^1` norm could be computed.


.. GENERATED FROM PYTHON SOURCE LINES 110-122

.. code-block:: Python


    u = KFormUnknown(2, "u", 0)
    v = u.weight
    q = KFormUnknown(2, "q", 1)
    p = q.weight

    system = KFormSystem(
        ALPHA * (v * u) == ALPHA * (v * final_u),
        p * q - p * u.derivative == 0,
        sorting=lambda f: f.order,
    )








.. GENERATED FROM PYTHON SOURCE LINES 123-130

Make the Mesh
-------------

Next the mesh would be created. In this case, it was taken to be a
convexly deformed square.



.. GENERATED FROM PYTHON SOURCE LINES 131-170

.. code-block:: Python


    N = 6
    P = 3

    n1 = N
    n2 = N


    rect_mesh, rx, ry = rmsh.create_elliptical_mesh(
        rmsh.MeshBlock(
            label=None,
            bottom=rmsh.BoundaryCurve.from_knots(n1, (-1, -1), (0, -2), (+1, -1)),
            right=rmsh.BoundaryCurve.from_knots(n2, (+1, -1), (+2, 0), (+1, +1)),
            top=rmsh.BoundaryCurve.from_knots(n2, (+1, +1), (0, +2), (-1, +1)),
            left=rmsh.BoundaryCurve.from_knots(n2, (-1, +1), (-2, 0), (-1, -1)),
        )
    )
    assert rx < 1e-6 and ry < 1e-6

    mesh = Mesh2D(
        P,
        np.stack((rect_mesh.pos_x, rect_mesh.pos_y), axis=-1),
        rect_mesh.lines + 1,
        rect_mesh.surfaces,
    )

    fig, ax = plt.subplots(1, 1)

    xlim, ylim = rect_mesh.plot(ax)
    ax.set(
        aspect="equal",
        xlim=(1.1 * xlim[0], 1.1 * xlim[1]),
        ylim=(1.1 * ylim[0], 1.1 * ylim[1]),
        xlabel="$x$",
        ylabel="$y$",
    )
    fig.tight_layout()
    plt.show()




.. image-sg:: /auto_examples/unsteady/images/sphx_glr_plot_reaction_001.png
   :alt: plot reaction
   :srcset: /auto_examples/unsteady/images/sphx_glr_plot_reaction_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 171-176

Run Unsteady Simulations
------------------------

With the mesh and system defined, the simulations can be run. The run is done for
10, 20, 50, 100, and 200 time steps.

.. GENERATED FROM PYTHON SOURCE LINES 177-230

.. code-block:: Python


    nt_vals = np.array((10, 20, 50, 100, 200))
    h1_err = np.zeros(nt_vals.size)
    l2_err = np.zeros(nt_vals.size)
    dt_vals = np.zeros(nt_vals.size)

    for i_nt, nt in enumerate(nt_vals):
        dt = float(T_END / nt)
        solutions, stats = solve_system_2d(
            mesh,
            system_settings=SystemSettings(system, initial_conditions={u: initial_u}),
            solver_settings=SolverSettings(
                maximum_iterations=10, relative_tolerance=0, absolute_tolerance=1e-10
            ),
            time_settings=TimeSettings(dt=dt, nt=nt, time_march_relations={v: u}),
            recon_order=25,
        )

        n_sol = len(solutions)
        h1_err_vals = np.zeros(n_sol)
        l2_err_vals = np.zeros(n_sol)
        time_vals = np.zeros(n_sol)

        for isol, sol in enumerate(solutions):
            time = float(sol.field_data["time"][0])

            u_exact = initial_u(sol.points[:, 0], sol.points[:, 1]) * np.exp(
                -ALPHA * time
            ) + final_u(sol.points[:, 0], sol.points[:, 1]) * (1 - np.exp(-ALPHA * time))
            q_exact = initial_q(sol.points[:, 0], sol.points[:, 1]) * np.exp(
                -ALPHA * time
            ) + final_q(sol.points[:, 0], sol.points[:, 1]) * (1 - np.exp(-ALPHA * time))

            u_err = sol.point_data["u"] - u_exact

            q_err = sol.point_data["q"] - q_exact
            sol.point_data["u_err"] = (u_err) ** 2
            # sol.point_data["u_real"] = u_exact
            sol.point_data["q_err"] = np.linalg.norm(q_err, axis=-1)
            # sol.point_data["q_real"] = q_exact

            integrated = sol.integrate_data()
            time_vals[isol] = time
            h1_err_vals[isol] = integrated.point_data["q_err"][0]
            l2_err_vals[isol] = np.sqrt(integrated.point_data["u_err"][0])

        total_h1_error = trapezoid(h1_err_vals, time_vals)
        total_l2_error = trapezoid(l2_err_vals, time_vals)
        h1_err[i_nt] = total_h1_error
        l2_err[i_nt] = total_l2_error
        dt_vals[i_nt] = dt
        # print(f"For {dt=} total error was {total_h1_error:.3e}.")








.. GENERATED FROM PYTHON SOURCE LINES 231-238

Plot the Time Error
-------------------

The total integrated time error in the two norms is now examined.

:math:`H^1` Norm
~~~~~~~~~~~~~~~~

.. GENERATED FROM PYTHON SOURCE LINES 239-263

.. code-block:: Python


    k1, k0 = np.polyfit(np.log(dt_vals), np.log(h1_err), 1)
    k0 = np.exp(k0)

    fig, ax = plt.subplots(1, 1)
    ax.scatter(dt_vals, h1_err)
    ax.plot(
        dt_vals,
        k0 * dt_vals**k1,
        linestyle="dashed",
        label=f"${k0:.3g} \\cdot {{\\Delta t}}^{{{k1:+.3g}}}$",
    )
    ax.grid()
    ax.legend()
    ax.set(
        xlabel="$\\Delta t$",
        ylabel="$\\int \\varepsilon_{H^{1}} {dt}$",
        xscale="log",
        yscale="log",
    )
    ax.xaxis_inverted()
    fig.tight_layout()
    plt.show()




.. image-sg:: /auto_examples/unsteady/images/sphx_glr_plot_reaction_002.png
   :alt: plot reaction
   :srcset: /auto_examples/unsteady/images/sphx_glr_plot_reaction_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 264-266

:math:`L^2` Norm
~~~~~~~~~~~~~~~~

.. GENERATED FROM PYTHON SOURCE LINES 267-292

.. code-block:: Python


    k1, k0 = np.polyfit(np.log(dt_vals), np.log(l2_err), 1)
    k0 = np.exp(k0)

    fig, ax = plt.subplots(1, 1)
    ax.scatter(dt_vals, l2_err)
    ax.plot(
        dt_vals,
        k0 * dt_vals**k1,
        linestyle="dashed",
        label=f"${k0:.3g} \\cdot {{\\Delta t}}^{{{k1:+.3g}}}$",
    )
    ax.grid()
    ax.legend()
    ax.set(
        xlabel="$\\Delta t$",
        ylabel="$\\int \\varepsilon_{L^{1}} {dt}$",
        xscale="log",
        yscale="log",
    )
    ax.xaxis_inverted()
    fig.tight_layout()
    plt.show()





.. image-sg:: /auto_examples/unsteady/images/sphx_glr_plot_reaction_003.png
   :alt: plot reaction
   :srcset: /auto_examples/unsteady/images/sphx_glr_plot_reaction_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 293-297

Plot Solution's Evolution
-------------------------

With :mod:`pyvista` the unsteady solution can even be plotted.

.. GENERATED FROM PYTHON SOURCE LINES 298-310

.. code-block:: Python


    plotter = pv.Plotter(off_screen=True, window_size=(1600, 800))

    plotter.open_gif("unsteady-reaction-direct-solution.gif", fps=30)

    for sol in solutions:
        sol.points[:, 2] = sol.point_data["u"]
        plotter.add_mesh(sol, scalars=None, name="solution", show_scalar_bar=False)
        plotter.add_text(f"time = {sol.field_data['time'][0]:.1f}", name="time")
        plotter.write_frame()

    plotter.close()



.. image-sg:: /auto_examples/unsteady/images/sphx_glr_plot_reaction_004.gif
   :alt: plot reaction
   :srcset: /auto_examples/unsteady/images/sphx_glr_plot_reaction_004.gif
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (1 minutes 27.826 seconds)


.. _sphx_glr_download_auto_examples_unsteady_plot_reaction.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_reaction.ipynb <plot_reaction.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_reaction.py <plot_reaction.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_reaction.zip <plot_reaction.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
